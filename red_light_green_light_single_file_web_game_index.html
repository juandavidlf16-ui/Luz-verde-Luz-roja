<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Luz Verde, Luz Roja — Mini Juego</title>
  <style>
    :root {
      --bg: #080b16;
      --panel: rgba(12, 17, 33, 0.96);
      --accent: #7dd3fc;
      --win: #22c55e;
      --lose: #ef4444;
      --text: #f8fafc;
      --muted: #9ca3af;
      --track: #10192f;
      --overlay: rgba(6, 10, 21, 0.88);
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(circle at 50% -20%, #243152 0%, var(--bg) 55%);
      font-family: "Inter", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans";
      color: var(--text);
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(1200px 900px at 30% 20%, rgba(59, 130, 246, 0.14), transparent 65%),
                  radial-gradient(1100px 800px at 70% 10%, rgba(244, 63, 94, 0.12), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .wrap { display: grid; place-items: center; min-height: 100%; padding: 24px; }

    .card {
      width: min(1024px, 96vw);
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.07);
      border-radius: 22px;
      box-shadow: 0 30px 80px rgba(0,0,0,.45);
      overflow: hidden;
      position: relative;
    }

    header { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 18px 22px; border-bottom: 1px solid rgba(255,255,255,.06); background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0)); }
    header h1 { font-size: clamp(20px, 3vw, 26px); margin: 0; letter-spacing: .4px; font-weight: 700; display: flex; align-items: center; gap: 10px; }
    header h1 span { font-size: 26px; filter: drop-shadow(0 0 6px rgba(125, 211, 252, .65)); }

    .badges { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pill { padding: 6px 12px; border-radius: 999px; font-size: 12px; letter-spacing: .3px; background: rgba(15, 24, 47, .8); border: 1px solid rgba(255,255,255,.08); color: var(--muted); }

    .state { font-weight: 800; padding: 6px 12px; border-radius: 999px; font-size: 12px; letter-spacing: .6px; text-transform: uppercase; box-shadow: 0 0 12px rgba(255,255,255,.12) inset; }
    .state.green { background: rgba(34,197,94,.18); color: #4ade80; border: 1px solid rgba(34,197,94,.4); }
    .state.red   { background: rgba(239,68,68,.18); color: #f87171; border: 1px solid rgba(239,68,68,.4); }

    canvas { display: block; width: 100%; height: auto; background: linear-gradient(#060a19 0 55%, #050813 55% 100%); image-rendering: optimizeQuality; }

    .panel { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; padding: 16px 22px; border-top: 1px solid rgba(255,255,255,.05); background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0)); }
    .meta { display: flex; gap: clamp(12px, 3vw, 28px); align-items: center; font-size: 13px; color: var(--muted); flex-wrap: wrap; }
    .meta strong { color: var(--text); font-size: 14px; }

    .controls { display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end; }
    button { appearance: none; border: 1px solid rgba(255,255,255,.12); background: rgba(10,18,35,.92); color: var(--text); padding: 10px 16px; border-radius: 12px; font-weight: 700; letter-spacing: .3px; cursor: pointer; transition: transform .06s ease, box-shadow .2s ease, border-color .2s ease; }
    button:hover { border-color: rgba(255,255,255,.25); box-shadow: 0 10px 22px rgba(15,23,42,.35); transform: translateY(-1px); }
    button:active { transform: translateY(0); }

    .move-btn { display: none; }

    @media (max-width: 760px) {
      .panel { grid-template-columns: 1fr; }
      .move-btn { display: inline-flex; }
      header { flex-direction: column; align-items: flex-start; gap: 16px; }
    }

    .toast { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .toast .bubble { padding: 14px 16px; border-radius: 14px; backdrop-filter: blur(10px); background: rgba(15,23,42,.66); border: 1px solid rgba(148,163,184,.3); font-size: 13px; color: var(--muted); box-shadow: 0 15px 40px rgba(2,6,23,.55); }

    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: var(--overlay);
      backdrop-filter: blur(14px);
      transition: opacity .3s ease;
      z-index: 20;
    }

    .overlay.hidden { opacity: 0; pointer-events: none; }

    .menu-card {
      width: min(760px, 92vw);
      background: rgba(10,18,36,.95);
      border-radius: 24px;
      padding: clamp(24px, 4vw, 36px);
      border: 1px solid rgba(148,163,184,.18);
      box-shadow: 0 40px 100px rgba(2,6,23,.55);
    }

    .menu-card h2 { margin: 0 0 10px; font-size: clamp(24px, 4vw, 34px); letter-spacing: .5px; }
    .menu-card p { margin: 0 0 26px; color: var(--muted); max-width: 60ch; }

    .choices { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 14px; margin-bottom: 24px; }
    .choice {
      background: linear-gradient(160deg, rgba(37,99,235,.16), rgba(148,163,184,.04));
      border: 1px solid rgba(148,163,184,.35);
      border-radius: 18px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      cursor: pointer;
      transition: transform .18s ease, border-color .18s ease, box-shadow .18s ease;
      position: relative;
      overflow: hidden;
    }

    .choice::after {
      content: "";
      position: absolute;
      inset: auto -40% -40% auto;
      width: 140px;
      height: 140px;
      background: radial-gradient(circle at center, rgba(125,211,252,.18), transparent 70%);
      transform: rotate(20deg);
      opacity: .0;
      transition: opacity .3s ease;
    }

    .choice:hover { transform: translateY(-4px); border-color: rgba(148, 163, 184, .55); box-shadow: 0 18px 45px rgba(15,23,42,.55); }
    .choice:hover::after { opacity: .7; }

    .choice.selected { border-color: rgba(56, 189, 248, .85); box-shadow: 0 20px 55px rgba(14,165,233,.35); }
    .choice.selected::after { opacity: 1; }

    .avatar-preview {
      height: 120px;
      background: rgba(15,23,42,.65);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.04);
      display: grid;
      place-items: center;
      position: relative;
      overflow: hidden;
    }

    .avatar-preview svg { width: 110px; height: 110px; filter: drop-shadow(0 12px 30px rgba(0,0,0,.35)); }

    .choice h3 { margin: 0; font-size: 18px; }
    .choice span { font-size: 13px; color: var(--muted); line-height: 1.4; }

    .primary {
      background: linear-gradient(130deg, rgba(56,189,248,.18), rgba(14,165,233,.22));
      border: 1px solid rgba(125,211,252,.6);
      color: var(--text);
      padding: 12px 20px;
      border-radius: 16px;
      font-size: 15px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-weight: 700;
    }

    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <header>
        <h1><span>✶</span>Luz Verde, Luz Roja — Mini Competencia</h1>
        <div class="badges">
          <span class="pill" id="statusPill">Selecciona tu corredor</span>
          <span class="state green" id="lightState">Luz Verde</span>
        </div>
      </header>

      <canvas id="game" width="1024" height="420" aria-label="Lienzo del juego"></canvas>

      <div class="panel">
        <div class="meta">
          <div>Progreso: <strong><span id="progress">0</span>%</strong></div>
          <div>Rango de luz: <strong><span id="rng">—</span></strong></div>
          <div>Cuenta regresiva: <strong><span id="countdown">—</span></strong></div>
          <div>Mejor tiempo: <strong><span id="best">—</span></strong></div>
        </div>
        <div class="controls">
          <button id="startBtn" title="Iniciar (Barra espaciadora)" disabled>Iniciar</button>
          <button id="moveBtn" class="move-btn" title="Mantener para avanzar">Mantener para avanzar</button>
          <button id="pushBtn" class="move-btn" title="Empujar">Empujar</button>
          <button id="resetBtn" title="Reiniciar">Reiniciar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="menu" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
    <div class="menu-card">
      <h2 id="menuTitle">Elige tu avatar</h2>
      <p>Compite contra los otros corredores en la pista. Mantén presionado <strong>W / Flecha ↑</strong> (o el botón táctil) para avanzar cuando la muñeca mire en otra dirección. Presiona <strong>E</strong> para empujar cuando estés cuerpo a cuerpo.</p>
      <div class="choices" id="characterChoices"></div>
      <button class="primary" id="confirmChoice">Listo para competir</button>
    </div>
  </div>

  <div class="toast" aria-live="polite" aria-atomic="true">
    <div class="bubble" id="hint">Mantén presionado <strong>W / Flecha ↑</strong> para avanzar. Suelta en 🔴. Empuja con <strong>E</strong>.</div>
  </div>

  <span class="sr-only" id="sr-status" role="status"></span>

  <script>
    // --- Definición de personajes ---
    const CHARACTERS = [
      {
        id: 'dog',
        name: 'Capitán Can',
        bio: 'Atlético, buen chico y con traje retro luminoso.',
        speed: 150,
        sprite: (ctx, x, y, phase) => drawAnthro(ctx, x, y, phase, {
          ears: 'pointy',
          palette: {
            fur: '#f9c784',
            muzzle: '#f0a870',
            suit: '#2563eb',
            suitAccent: '#93c5fd',
            detail: '#1e3a8a'
          },
          tail: true,
          snout: true
        })
      },
      {
        id: 'cat',
        name: 'Mystica Felina',
        bio: 'Ágil, equilibrada y con reflejos felinos exagerados.',
        speed: 160,
        sprite: (ctx, x, y, phase) => drawAnthro(ctx, x, y, phase, {
          ears: 'feline',
          palette: {
            fur: '#fbbf24',
            muzzle: '#fde68a',
            suit: '#8b5cf6',
            suitAccent: '#c4b5fd',
            detail: '#6b21a8'
          },
          tail: true,
          snout: false
        })
      },
      {
        id: 'mole',
        name: 'Topo Forajido',
        bio: 'No ve muy bien, pero resiste los empujones como nadie.',
        speed: 140,
        sprite: (ctx, x, y, phase) => drawAnthro(ctx, x, y, phase, {
          ears: 'round',
          palette: {
            fur: '#9ca3af',
            muzzle: '#d1d5db',
            suit: '#f97316',
            suitAccent: '#fdba74',
            detail: '#9a3412'
          },
          tail: false,
          snout: true,
          goggles: true
        })
      }
    ];

    const WORLD_LEN = 1700;
    const PLAYER_ACCEL = 8.5;
    const PLAYER_FRICTION = 6.2;
    const PUSH_FORCE = 85;
    const PUSH_COOLDOWN = 0.6;
    const RUNNER_RADIUS = 18;
    const LANES = [-48, 0, 48];
    const ROUND_TIME = 45; // segundos
    const GREEN_RANGE = [1300, 2600];
    const RED_RANGE = [900, 1900];

    // --- Estado global ---
    let selectedCharacter = null;
    let running = false, gameOver = false, won = false;
    let lightIsGreen = true;
    let dollAngle = 0;
    let tLast = 0;
    let bestTime = null;
    let runTime = 0;
    let timeLeft = ROUND_TIME;
    let lightTimer = 0, lightTTL = randRange(GREEN_RANGE);

    let competitors = [];

    // --- DOM ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const progressEl = document.getElementById('progress');
    const rngEl = document.getElementById('rng');
    const countdownEl = document.getElementById('countdown');
    const statusPill = document.getElementById('statusPill');
    const lightStateEl = document.getElementById('lightState');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const moveBtn = document.getElementById('moveBtn');
    const pushBtn = document.getElementById('pushBtn');
    const srStatus = document.getElementById('sr-status');
    const menu = document.getElementById('menu');
    const choiceContainer = document.getElementById('characterChoices');
    const confirmChoice = document.getElementById('confirmChoice');

    // --- Entrada ---
    let movingInput = false;
    let pushingInput = false;
    let pushCooldown = 0;

    function handleDown(e) {
      if (['w','W','ArrowUp'].includes(e.key)) { movingInput = true; }
      if (e.key === ' ') { startRun(); }
      if (e.key === 'e' || e.key === 'E') { pushingInput = true; }
    }

    function handleUp(e) {
      if (['w','W','ArrowUp'].includes(e.key)) { movingInput = false; }
      if (e.key === 'e' || e.key === 'E') { pushingInput = false; }
    }

    window.addEventListener('keydown', handleDown);
    window.addEventListener('keyup', handleUp);

    moveBtn.addEventListener('pointerdown', () => movingInput = true);
    moveBtn.addEventListener('pointerup',   () => movingInput = false);
    moveBtn.addEventListener('pointerleave',() => movingInput = false);

    pushBtn.addEventListener('pointerdown', () => pushingInput = true);
    pushBtn.addEventListener('pointerup',   () => pushingInput = false);
    pushBtn.addEventListener('pointerleave',() => pushingInput = false);

    startBtn.addEventListener('click', startRun);
    resetBtn.addEventListener('click', () => reset());

    confirmChoice.addEventListener('click', () => {
      if (!selectedCharacter) return;
      menu.classList.add('hidden');
      statusPill.textContent = 'Listo';
      startBtn.disabled = false;
      reset(false);
      toggleLight(true);
      announce(`${selectedCharacter.name} listo para competir.`);
    });

    // Crear botones de selección
    CHARACTERS.forEach(character => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'choice';
      btn.innerHTML = `
        <div class="avatar-preview">${renderCharacterPreview(character)}</div>
        <div>
          <h3>${character.name}</h3>
          <span>${character.bio}</span>
        </div>`;
      btn.addEventListener('click', () => {
        selectedCharacter = character;
        document.querySelectorAll('.choice').forEach(el => el.classList.remove('selected'));
        btn.classList.add('selected');
      });
      choiceContainer.appendChild(btn);
    });

    // --- Utilidades ---
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    function randRange([a, b]) { return Math.floor(a + Math.random() * (b - a)); }
    function announce(msg) { srStatus.textContent = msg; }

    function toggleLight(force) {
      lightIsGreen = force ?? !lightIsGreen;
      dollAngle = lightIsGreen ? 0 : 1;
      lightTTL = lightIsGreen ? randRange(GREEN_RANGE) : randRange(RED_RANGE);
      lightStateEl.className = `state ${lightIsGreen ? 'green' : 'red'}`;
      lightStateEl.textContent = lightIsGreen ? 'Luz Verde' : 'Luz Roja';
      rngEl.textContent = `${lightTTL} ms`;
      announce(lightIsGreen ? 'Luz verde, avanza' : 'Luz roja, quieto');
      competitors.forEach(runner => {
        if (!runner.isPlayer) {
          runner.aiTimer = 0;
          runner.aiDelay = lightIsGreen ? Math.random() * 0.3 : Math.random() * 0.25;
        }
      });
    }

    function createCompetitors() {
      if (!selectedCharacter) return;
      competitors = [];
      const available = CHARACTERS.filter(c => c.id !== selectedCharacter.id);
      const pool = [selectedCharacter, ...available];
      const lanes = [0, 1, 2];
      for (let i = 0; i < pool.length; i++) {
        const lane = lanes[i % lanes.length];
        const char = pool[i % pool.length];
        const isPlayer = i === 0;
        competitors.push({
          character: char,
          isPlayer,
          lane,
          x: 70,
          v: 0,
          targetV: 0,
          stun: 0,
          aiTimer: 0,
          aiDelay: Math.random() * 0.3,
          reaction: 0.45 + Math.random() * 0.35,
          baseSpeed: char.speed * (isPlayer ? 1 : 0.88 + Math.random() * 0.18),
          name: char.name,
          eliminated: false
        });
      }
    }

    function reset(resetLight = true) {
      running = false; gameOver = false; won = false;
      runTime = 0; timeLeft = ROUND_TIME; pushCooldown = 0;
      progressEl.textContent = '0';
      countdownEl.textContent = `${timeLeft.toFixed(0)} s`;
      statusPill.textContent = selectedCharacter ? 'Listo' : 'Selecciona tu corredor';
      lightTimer = 0;
      if (resetLight) toggleLight(true);
      if (selectedCharacter) {
        createCompetitors();
      }
      draw();
    }

    function startRun() {
      if (running || !selectedCharacter || menu && !menu.classList.contains('hidden')) return;
      reset(false);
      toggleLight(true);
      running = true;
      tLast = performance.now();
      statusPill.textContent = 'En juego';
      requestAnimationFrame(loop);
    }

    // --- Lógica ---
    function step(dt) {
      if (!running) return;

      lightTimer += dt * 1000;
      if (lightTimer >= lightTTL) {
        lightTimer = 0;
        toggleLight();
      }

      timeLeft = clamp(timeLeft - dt, 0, ROUND_TIME);
      countdownEl.textContent = `${timeLeft.toFixed(1)} s`;
      if (timeLeft <= 0 && !won) {
        gameOver = true;
        running = false;
        statusPill.textContent = 'Tiempo agotado';
        flash('#ef4444');
        return;
      }

      const player = competitors.find(r => r.isPlayer);
      if (!player) return;

      // Actualizar entradas
      player.targetV = movingInput && lightIsGreen && !gameOver ? player.baseSpeed : 0;
      const accel = movingInput && lightIsGreen ? PLAYER_ACCEL : PLAYER_FRICTION;
      player.v += (player.targetV - player.v) * clamp(accel * dt, 0, 1);

      if (!lightIsGreen && Math.abs(player.v) > 12 && !gameOver) {
        gameOver = true; running = false; statusPill.textContent = 'Te descubrieron'; flash('#ef4444');
      }

      // IA oponentes
      competitors.forEach(runner => {
        if (runner.isPlayer) return;
        runner.aiTimer += dt;
        const desired = lightIsGreen ? runner.baseSpeed : 0;
        const ready = runner.aiTimer >= runner.aiDelay;
        const applySpeed = ready ? desired : runner.targetV;
        const smoothing = lightIsGreen ? (4.5 + Math.random()*0.8) : (6.5 + Math.random()*1.2);
        runner.targetV = applySpeed;
        runner.v += (runner.targetV - runner.v) * clamp(smoothing * dt, 0, 1);
        if (!lightIsGreen && Math.abs(runner.v) > 15 && !runner.eliminated) {
          runner.eliminated = true;
          runner.v = 0;
        }
        if (runner.eliminated) {
          runner.v += (0 - runner.v) * clamp(8 * dt, 0, 1);
        }
      });

      pushCooldown = Math.max(0, pushCooldown - dt);

      // Integrar posiciones
      competitors.forEach(runner => {
        runner.stun = Math.max(0, runner.stun - dt);
        if (runner.stun > 0.0001) {
          runner.v += (0 - runner.v) * clamp(6 * dt, 0, 1);
        }
        runner.x += runner.v * dt;
        runner.x = clamp(runner.x, 70, WORLD_LEN);
      });

      // Colisiones y empujes
      resolveCollisions(dt);

      // Verificar victoria
      if (player.x >= WORLD_LEN && !gameOver) {
        won = true;
        running = false;
        statusPill.textContent = '¡Ganaste!';
        if (!bestTime || runTime < bestTime) bestTime = runTime;
        flash('#22c55e');
      }

      // Si un rival llega primero
      competitors.forEach(runner => {
        if (!runner.isPlayer && runner.x >= WORLD_LEN && !runner.eliminated && !gameOver && !won) {
          gameOver = true;
          running = false;
          statusPill.textContent = `${runner.name} ganó`; 
          flash('#f97316');
        }
      });

      const prog = Math.round(((player.x - 70) / (WORLD_LEN - 70)) * 100);
      progressEl.textContent = clamp(prog, 0, 100);
      runTime += running ? dt : 0;
      document.getElementById('best').textContent = bestTime ? `${bestTime.toFixed(2)} s` : '—';
    }

    function resolveCollisions(dt) {
      for (let i = 0; i < competitors.length; i++) {
        for (let j = i + 1; j < competitors.length; j++) {
          const a = competitors[i];
          const b = competitors[j];
          const ay = laneToY(a.lane);
          const by = laneToY(b.lane);
          const dx = a.x - b.x;
          const dy = ay - by;
          const dist = Math.hypot(dx, dy);
          if (dist < RUNNER_RADIUS * 2) {
            const overlap = RUNNER_RADIUS * 2 - dist;
            const nx = dist === 0 ? 0 : dx / dist;
            const ny = dist === 0 ? 0 : dy / dist;
            const sep = overlap / 2;
            a.x += nx * sep;
            b.x -= nx * sep;
            // Empuje
            const player = a.isPlayer ? a : (b.isPlayer ? b : null);
            const other = player === a ? b : (player === b ? a : null);
            if (player && other && pushingInput && pushCooldown <= 0) {
              other.v = Math.max(other.v - PUSH_FORCE * 0.6, -PUSH_FORCE);
              other.stun = 0.4;
              player.v *= 0.75;
              flash('#38bdf8');
              pushCooldown = PUSH_COOLDOWN;
            }
          }
        }
      }
    }

    function loop(now) {
      const dt = Math.min((now - tLast) / 1000, 0.25);
      tLast = now;
      step(dt);
      draw();
      if (running) requestAnimationFrame(loop);
    }

    // --- Render ---
    function draw() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      drawBackground(w, h);

      const camX = computeCameraX(w);
      ctx.save();
      ctx.translate(-camX, 0);

      const trackY = 320;
      drawTrack(w, trackY);
      drawGoal(WORLD_LEN, trackY);
      drawPost(70, trackY, '#475569');
      drawDoll(250, 160, dollAngle);

      const sorted = [...competitors].sort((a, b) => laneToY(b.lane) - laneToY(a.lane));
      sorted.forEach(runner => drawRunner(runner, trackY));

      ctx.restore();

      drawLeaderboard();
    }

    function drawBackground(w, h) {
      const gradient = ctx.createLinearGradient(0, 0, 0, h);
      gradient.addColorStop(0, '#0b1430');
      gradient.addColorStop(0.45, '#111c3d');
      gradient.addColorStop(1, '#070b18');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);

      // Montañas
      ctx.fillStyle = '#0d1a36';
      ctx.beginPath();
      ctx.moveTo(0, 220);
      ctx.quadraticCurveTo(120, 120, 260, 210);
      ctx.quadraticCurveTo(420, 80, 620, 210);
      ctx.quadraticCurveTo(760, 140, 900, 230);
      ctx.lineTo(w, 260);
      ctx.lineTo(w, 0);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#132147';
      ctx.beginPath();
      ctx.moveTo(0, 260);
      ctx.quadraticCurveTo(140, 170, 320, 250);
      ctx.quadraticCurveTo(520, 150, 780, 260);
      ctx.lineTo(w, 280);
      ctx.lineTo(w, 0);
      ctx.lineTo(0, 0);
      ctx.closePath();
      ctx.fill();

      // Luces del público
      const t = performance.now() / 1000;
      for (let i = 0; i < 30; i++) {
        const x = (i * 180 + performance.now()/20) % (w + 120) - 60;
        const y = 260 + Math.sin((i * 0.6 + t)) * 6;
        const radius = 2.8 + Math.sin(t * 3 + i) * 0.6;
        const alpha = 0.16 + Math.sin(t * 2 + i * 1.3) * 0.08;
        ctx.fillStyle = `rgba(148, 163, 184, ${alpha.toFixed(3)})`;
        ctx.beginPath();
        ctx.ellipse(x, y, radius, radius * 0.5, 0, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawTrack(w, trackY) {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(-100, trackY, WORLD_LEN + 400, 80);
      const laneColor = 'rgba(148,163,184,.24)';
      LANES.forEach(offset => {
        ctx.strokeStyle = laneColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-100, trackY - 10 + offset);
        ctx.lineTo(WORLD_LEN + 240, trackY - 10 + offset);
        ctx.stroke();
      });
      ctx.fillStyle = 'rgba(30,64,175,.6)';
      ctx.fillRect(-100, trackY + 32, WORLD_LEN + 400, 6);
    }

    function drawGoal(x, trackY) {
      const poleH = 240; const poleW = 12;
      ctx.fillStyle = '#94a3b8';
      ctx.fillRect(x, trackY - poleH, poleW, poleH);
      const flagW = 68, flagH = 44; const cell = 8;
      for (let i = 0; i < flagW / cell; i++) {
        for (let j = 0; j < flagH / cell; j++) {
          ctx.fillStyle = (i + j) % 2 === 0 ? '#111827' : '#e5e7eb';
          ctx.fillRect(x + poleW + i*cell, trackY - poleH + 8 + j*cell, cell, cell);
        }
      }
    }

    function drawPost(x, trackY, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x - 6, trackY - 220, 12, 220);
    }

    function laneToY(lane) {
      return 310 - LANES[lane];
    }

    function drawRunner(runner, trackY) {
      const px = runner.x;
      const py = laneToY(runner.lane);
      ctx.save();
      ctx.translate(px, py);
      const t = performance.now() / 140;
      const step = Math.sin(t + runner.lane) * 10 * (runner.v / Math.max(60, runner.baseSpeed));
      ctx.fillStyle = 'rgba(15,23,42,.6)';
      ctx.beginPath();
      ctx.ellipse(0, 26, 28, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      runner.character.sprite(ctx, 0, 0, step);
      ctx.restore();
    }

    function drawLeaderboard() {
      const panelW = 220;
      const x = canvas.width - panelW - 24;
      const y = 24;
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = 'rgba(15,23,42,.72)';
      roundedRect(ctx, x, y, panelW, 140, 16);
      ctx.fill();
      ctx.strokeStyle = 'rgba(148,163,184,.25)';
      ctx.lineWidth = 1;
      roundedRect(ctx, x, y, panelW, 140, 16);
      ctx.stroke();
      ctx.restore();

      const list = [...competitors].sort((a, b) => b.x - a.x);
      ctx.save();
      ctx.translate(x + 18, y + 22);
      ctx.fillStyle = '#cbd5f5';
      ctx.font = '600 14px "Inter"';
      ctx.fillText('Clasificación', 0, 0);
      ctx.font = '500 13px "Inter"';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText('Meta en 1700m', 0, 18);
      ctx.translate(0, 34);

      list.forEach((runner, idx) => {
        const name = runner.isPlayer ? 'Tú' : runner.name;
        const progress = Math.round(((runner.x - 70) / (WORLD_LEN - 70)) * 100);
        ctx.fillStyle = runner.isPlayer ? '#f8fafc' : '#e2e8f0';
        ctx.fillText(`${idx + 1}. ${name}`, 0, idx * 24);
        ctx.fillStyle = 'rgba(148,163,184,.28)';
        ctx.fillRect(120, idx * 24 - 10, 100, 6);
        ctx.fillStyle = '#38bdf8';
        ctx.fillRect(120, idx * 24 - 10, clamp(progress,0,100), 6);
        ctx.fillStyle = '#94a3b8';
        ctx.fillText(`${clamp(progress, 0, 100)}%`, 196, idx * 24);
      });
      ctx.restore();
    }

    function drawDoll(x, y, look) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = '#1e293b';
      ctx.beginPath();
      ctx.ellipse(0, 140, 90, 26, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(0, 0, 40, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#0f172a';
      const eyeShift = look ? 10 : -10;
      ctx.beginPath();
      ctx.arc(-14 + eyeShift*0.5, -6, 6, 0, Math.PI*2);
      ctx.arc(14 + eyeShift*0.6, -6, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fbbf24';
      ctx.fillRect(-16, 40, 32, 60);
      ctx.fillStyle = '#22c55e';
      ctx.fillRect(-30, 100, 60, 60);
      ctx.restore();
    }

    function drawAnthro(ctx, x, y, phase, options) {
      const { palette, ears, tail, snout, goggles } = options;
      ctx.save();
      ctx.translate(x, y);

      // Cuerpo
      ctx.fillStyle = palette.suit;
      roundedRect(ctx, -16, -6, 32, 42, 12);
      ctx.fill();
      ctx.fillStyle = palette.suitAccent;
      ctx.fillRect(-10, -4, 20, 6);
      ctx.fillRect(-6, 12, 12, 26);

      // Piernas
      ctx.save();
      ctx.translate(0, 28);
      ctx.rotate(0.08 * Math.sin(phase));
      ctx.fillStyle = palette.detail;
      roundedRect(ctx, -16, 0, 12, 26, 6);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(8, 28);
      ctx.rotate(-0.08 * Math.sin(phase));
      ctx.fillStyle = palette.detail;
      roundedRect(ctx, -6, 0, 12, 26, 6);
      ctx.fill();
      ctx.restore();

      // Brazos
      ctx.save();
      ctx.translate(-18, 4);
      ctx.rotate(-0.25 + 0.12 * Math.sin(phase));
      ctx.fillStyle = palette.suitAccent;
      roundedRect(ctx, -6, 0, 12, 24, 6);
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.translate(18, 6);
      ctx.rotate(0.3 + 0.12 * Math.sin(phase + 0.5));
      ctx.fillStyle = palette.suitAccent;
      roundedRect(ctx, -6, 0, 12, 24, 6);
      ctx.fill();
      ctx.restore();

      // Cabeza
      ctx.fillStyle = palette.fur;
      ctx.beginPath();
      ctx.arc(0, -20, 18, 0, Math.PI * 2);
      ctx.fill();

      if (ears === 'pointy') {
        drawEar(ctx, -14, -34, palette.fur, '#f59e0b', 'pointy');
        drawEar(ctx, 14, -34, palette.fur, '#f59e0b', 'pointy');
      } else if (ears === 'feline') {
        drawEar(ctx, -12, -30, palette.fur, '#fde68a', 'feline');
        drawEar(ctx, 12, -30, palette.fur, '#fde68a', 'feline');
      } else {
        drawEar(ctx, -10, -28, palette.fur, '#d1d5db', 'round');
        drawEar(ctx, 10, -28, palette.fur, '#d1d5db', 'round');
      }

      if (tail) {
        ctx.save();
        ctx.translate(-20, 10);
        ctx.rotate(-0.3 + 0.2 * Math.sin(phase));
        ctx.fillStyle = palette.fur;
        ctx.beginPath();
        roundedRect(ctx, -4, -4, 18, 12, 6);
        ctx.fill();
        ctx.restore();
      }

      // Hocico
      if (snout) {
        ctx.fillStyle = palette.muzzle;
        ctx.beginPath();
        ctx.ellipse(0, -14, 12, 8, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // Ojos
      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.arc(-6, -22, 3.4, 0, Math.PI * 2);
      ctx.arc(6, -22, 3.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f1f5f9';
      ctx.beginPath();
      ctx.arc(-4.5, -23, 1.4, 0, Math.PI * 2);
      ctx.arc(7.5, -23, 1.4, 0, Math.PI * 2);
      ctx.fill();

      if (goggles) {
        ctx.strokeStyle = '#facc15';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(-6, -22, 5, 0, Math.PI * 2);
        ctx.arc(6, -22, 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-1, -22);
        ctx.lineTo(1, -22);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawEar(ctx, x, y, color, inner, type) {
      ctx.save();
      ctx.translate(x, y);
      ctx.fillStyle = color;
      ctx.beginPath();
      if (type === 'pointy') {
        ctx.moveTo(0, 0);
        ctx.lineTo(-6, -14);
        ctx.lineTo(6, -14);
      } else if (type === 'feline') {
        ctx.moveTo(0, 0);
        ctx.lineTo(-7, -12);
        ctx.lineTo(7, -12);
      } else {
        ctx.arc(0, -6, 6, Math.PI, 0);
      }
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = inner;
      ctx.beginPath();
      if (type === 'round') {
        ctx.arc(0, -6, 4, Math.PI, 0);
      } else {
        ctx.moveTo(0, -2);
        ctx.lineTo(-3, -8);
        ctx.lineTo(3, -8);
        ctx.closePath();
      }
      ctx.fill();
      ctx.restore();
    }

    function renderCharacterPreview(character) {
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', '0 0 120 120');
      svg.innerHTML = `
        <defs>
          <linearGradient id="grad-${character.id}" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0%" stop-color="rgba(125,211,252,.35)" />
            <stop offset="100%" stop-color="rgba(14,165,233,.0)" />
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="120" height="120" rx="22" fill="url(#grad-${character.id})" />
        <text x="60" y="104" fill="rgba(148,163,184,.9)" font-family="Inter, sans-serif" font-weight="600" font-size="14" text-anchor="middle">${character.name}</text>
      `;
      return svg.outerHTML;
    }

    function flash(color) {
      const el = document.body;
      el.animate([
        { boxShadow: 'inset 0 0 0 0 rgba(0,0,0,0)' },
        { boxShadow: `inset 0 0 0 9999px ${color}18` },
        { boxShadow: 'inset 0 0 0 0 rgba(0,0,0,0)' }
      ], { duration: 600, easing: 'ease' });
    }

    function computeCameraX(viewWidth) {
      const player = competitors.find(r => r.isPlayer);
      if (!player) return 0;
      return clamp(player.x - viewWidth * 0.3, 0, Math.max(0, WORLD_LEN - viewWidth + 280));
    }

    function roundedRect(ctx, x, y, w, h, r) {
      if (ctx.roundRect) {
        ctx.beginPath();
        ctx.roundRect(x, y, w, h, r);
      } else {
        const radiusValue = typeof r === 'number' ? { tl: r, tr: r, br: r, bl: r } : Array.isArray(r)
          ? { tl: r[0], tr: r[1] ?? r[0], br: r[2] ?? r[0], bl: r[3] ?? r[1] ?? r[0] }
          : { tl: r.tl, tr: r.tr, br: r.br, bl: r.bl };
        ctx.beginPath();
        ctx.moveTo(x + radiusValue.tl, y);
        ctx.lineTo(x + w - radiusValue.tr, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radiusValue.tr);
        ctx.lineTo(x + w, y + h - radiusValue.br);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radiusValue.br, y + h);
        ctx.lineTo(x + radiusValue.bl, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radiusValue.bl);
        ctx.lineTo(x, y + radiusValue.tl);
        ctx.quadraticCurveTo(x, y, x + radiusValue.tl, y);
        ctx.closePath();
      }
    }

    // --- Inicialización ---
    reset();
    draw();
  </script>
</body>
</html>
