<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Luz Verde, Luz Roja — Arena Antropomorfa</title>
    <style>
      :root {
        --bg: radial-gradient(circle at 20% 20%, #1f3b73 0%, #040510 60%);
        --panel: rgba(9, 15, 32, 0.88);
        --accent: #7dd3fc;
        --win: #34d399;
        --lose: #f87171;
        --text: #f8fafc;
        --muted: #9ca3af;
        --track: #0d1729;
        --lane: rgba(148, 163, 184, 0.08);
        --finish: rgba(248, 113, 113, 0.5);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: var(--text);
        background: var(--bg);
        overflow: hidden;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(900px 600px at 80% 20%, rgba(56, 189, 248, 0.25), transparent 70%),
          radial-gradient(750px 520px at 15% 15%, rgba(244, 114, 182, 0.22), transparent 75%),
          linear-gradient(130deg, rgba(14, 22, 40, 0.8), transparent 65%);
        pointer-events: none;
        mix-blend-mode: screen;
      }

      main {
        height: 100%;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px clamp(16px, 4vw, 40px);
        backdrop-filter: blur(12px);
        background: linear-gradient(180deg, rgba(9, 15, 32, 0.85), rgba(9, 15, 32, 0.35));
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        position: relative;
        z-index: 2;
      }

      header h1 {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: clamp(20px, 4vw, 30px);
        margin: 0;
        letter-spacing: 0.5px;
      }

      header h1 span {
        font-size: 32px;
        filter: drop-shadow(0 0 8px rgba(125, 211, 252, 0.8));
      }

      .status-bar {
        display: flex;
        gap: clamp(12px, 2vw, 28px);
        align-items: center;
        font-size: 13px;
        color: var(--muted);
        flex-wrap: wrap;
      }

      .status-pill {
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(9, 15, 32, 0.72);
        font-weight: 600;
        letter-spacing: 0.4px;
        text-transform: uppercase;
      }

      .status-pill.green {
        color: #4ade80;
        border-color: rgba(52, 211, 153, 0.4);
        background: rgba(34, 197, 94, 0.16);
      }

      .status-pill.red {
        color: #f87171;
        border-color: rgba(248, 113, 113, 0.4);
        background: rgba(248, 113, 113, 0.16);
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: linear-gradient(#060815 0%, #03040a 60%);
      }

      footer {
        padding: 12px clamp(16px, 4vw, 40px);
        font-size: 13px;
        color: var(--muted);
        backdrop-filter: blur(12px);
        background: linear-gradient(0deg, rgba(9, 15, 32, 0.85), rgba(9, 15, 32, 0.35));
        border-top: 1px solid rgba(148, 163, 184, 0.18);
        display: flex;
        justify-content: space-between;
        gap: 14px;
        flex-wrap: wrap;
      }

      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(2, 8, 23, 0.86);
        backdrop-filter: blur(18px);
        z-index: 5;
        transition: opacity 0.4s ease;
      }

      .overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .menu-card {
        width: min(940px, 92vw);
        background: linear-gradient(160deg, rgba(13, 20, 40, 0.92), rgba(8, 13, 28, 0.88));
        border-radius: 28px;
        border: 1px solid rgba(125, 211, 252, 0.18);
        box-shadow: 0 40px 120px rgba(2, 6, 23, 0.75);
        padding: clamp(28px, 5vw, 46px);
        color: var(--text);
        position: relative;
        overflow: hidden;
      }

      .menu-card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(640px 360px at 85% 18%, rgba(14, 165, 233, 0.3), transparent 70%);
        mix-blend-mode: screen;
        opacity: 0.6;
        pointer-events: none;
      }

      .menu-header {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: center;
        margin-bottom: 24px;
      }

      .menu-header h2 {
        margin: 0;
        font-size: clamp(26px, 5vw, 40px);
        letter-spacing: 0.4px;
      }

      .menu-grid {
        display: grid;
        grid-template-columns: minmax(240px, 1fr) minmax(340px, 1.1fr);
        gap: clamp(20px, 3vw, 32px);
      }

      .menu-info {
        display: grid;
        gap: 18px;
      }

      .menu-info ul {
        margin: 0;
        padding-left: 18px;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.6;
      }

      .menu-selector {
        display: grid;
        gap: 18px;
      }

      .choices {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
      }

      .choice {
        position: relative;
        padding: 18px;
        border-radius: 22px;
        border: 1px solid rgba(125, 211, 252, 0.2);
        background: linear-gradient(160deg, rgba(37, 99, 235, 0.22), rgba(13, 20, 40, 0.7));
        box-shadow: 0 16px 50px rgba(2, 6, 23, 0.55);
        cursor: pointer;
        display: grid;
        gap: 14px;
        transition: transform 0.24s ease, border-color 0.24s ease, box-shadow 0.24s ease;
      }

      .choice:hover,
      .choice.active {
        transform: translateY(-4px);
        border-color: rgba(125, 211, 252, 0.45);
        box-shadow: 0 26px 70px rgba(14, 165, 233, 0.25);
      }

      .choice strong {
        font-size: 16px;
        letter-spacing: 0.4px;
      }

      .choice p {
        margin: 0;
        font-size: 13px;
        color: var(--muted);
      }

      .choice span {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.35px;
        color: rgba(190, 242, 255, 0.75);
      }

      .action-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
      }

      button {
        appearance: none;
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(8, 13, 28, 0.85);
        color: var(--text);
        padding: 12px 18px;
        border-radius: 14px;
        font-weight: 700;
        letter-spacing: 0.3px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }

      button:hover {
        transform: translateY(-2px);
        border-color: rgba(125, 211, 252, 0.45);
        box-shadow: 0 16px 40px rgba(14, 165, 233, 0.25);
      }

      button:active {
        transform: translateY(0);
      }

      .hud {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        pointer-events: none;
        padding: clamp(18px, 3vw, 28px);
        font-size: 14px;
        color: var(--muted);
      }

      .hud-top {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
      }

      .hud-card {
        background: rgba(8, 13, 28, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 16px;
        padding: 12px 16px;
        min-width: 190px;
        pointer-events: auto;
        backdrop-filter: blur(12px);
      }

      .hud-card h3 {
        margin: 0 0 6px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.35px;
        color: rgba(190, 242, 255, 0.7);
      }

      .hud-card ul {
        margin: 0;
        padding-left: 18px;
        font-size: 13px;
        color: var(--muted);
      }

      .hud .light-indicator {
        font-weight: 700;
        letter-spacing: 0.4px;
        text-transform: uppercase;
        color: var(--text);
      }

      .hud-bottom {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 16px;
        flex-wrap: wrap;
      }

      .ranking {
        display: grid;
        gap: 6px;
        font-size: 13px;
      }

      .ranking span {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        background: rgba(8, 13, 28, 0.6);
        border-radius: 10px;
        padding: 6px 10px;
      }

      .mobile-controls {
        display: none;
        gap: 10px;
        pointer-events: auto;
      }

      .mobile-controls button {
        min-width: 64px;
        font-size: 14px;
        padding: 12px;
        border-radius: 16px;
      }

      @media (max-width: 780px) {
        header,
        footer {
          position: relative;
          z-index: 4;
        }

        .menu-grid {
          grid-template-columns: 1fr;
        }

        .hud-card {
          display: none;
        }

        .mobile-controls {
          display: flex;
        }
      }

      .toast {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        pointer-events: none;
        z-index: 6;
      }

      .toast-message {
        background: rgba(8, 13, 28, 0.8);
        border: 1px solid rgba(125, 211, 252, 0.35);
        padding: 16px 22px;
        border-radius: 18px;
        font-size: 15px;
        box-shadow: 0 18px 70px rgba(2, 6, 23, 0.65);
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1><span>◎</span>Luz Verde · Luz Roja</h1>
        <div class="status-bar">
          <div class="status-pill" id="roundStatus">Selecciona un corredor</div>
          <div class="status-pill" id="lightStatus">—</div>
          <div class="status-pill" id="timeStatus">Tiempo —</div>
        </div>
      </header>
      <section style="position: relative; flex: 1;">
        <canvas id="game" width="960" height="540"></canvas>
        <div class="hud" aria-live="polite">
          <div class="hud-top">
            <div class="hud-card" id="objectiveCard">
              <h3>Objetivo</h3>
              <ul>
                <li>Avanza con luz verde y detente con luz roja.</li>
                <li>Empuja rivales cuando estés cerca.</li>
                <li>Llega a la meta antes de que se agote el tiempo.</li>
              </ul>
            </div>
            <div class="hud-card" id="statsCard"></div>
          </div>
          <div class="hud-bottom">
            <div class="ranking" id="ranking"></div>
            <div class="mobile-controls">
              <button id="mobileUp">Avanzar</button>
              <button id="mobilePush">Empujar</button>
            </div>
          </div>
        </div>
        <div class="toast" id="toast" aria-live="assertive"></div>
      </section>
      <footer>
        <span>Controles: ↑ o W para avanzar · ←/→ para mantener el carril · Barra espaciadora para empujar</span>
        <span>Toque en pantallas táctiles: botones inferiores</span>
      </footer>
    </main>

    <div class="overlay" id="menu">
      <article class="menu-card">
        <div class="menu-header">
          <h2>Arena Antropomorfa</h2>
          <p style="max-width: 48ch; color: var(--muted);">
            Elige a tu corredor y enfréntate a dos rivales IA en una carrera mortal inspirada en el juego del calamar. La muñeca de
            vigilancia alternará las luces de manera impredecible.
          </p>
        </div>
        <div class="menu-grid">
          <section class="menu-info">
            <div>
              <span class="status-pill">Modo Competencia</span>
              <h3 style="margin: 12px 0 6px; font-size: 15px; letter-spacing: 0.4px;">Instrucciones rápidas</h3>
              <ul>
                <li>Arranca solo cuando se ilumine en verde.</li>
                <li>Suéltate por completo con rojo o perderás.</li>
                <li>Acércate y pulsa empujar para desequilibrar a tus oponentes.</li>
                <li>Tienes 45 segundos para cruzar la línea de meta.</li>
              </ul>
            </div>
          </section>
          <section class="menu-selector">
            <div class="choices" id="choiceList"></div>
            <div class="action-buttons">
              <button id="startBtn" disabled>Comenzar partida</button>
              <button id="viewKeys">Ver controles</button>
            </div>
          </section>
        </div>
      </article>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const menu = document.getElementById("menu");
      const startBtn = document.getElementById("startBtn");
      const viewKeys = document.getElementById("viewKeys");
      const choiceList = document.getElementById("choiceList");
      const roundStatus = document.getElementById("roundStatus");
      const lightStatus = document.getElementById("lightStatus");
      const timeStatus = document.getElementById("timeStatus");
      const statsCard = document.getElementById("statsCard");
      const rankingEl = document.getElementById("ranking");
      const toast = document.getElementById("toast");
      const mobileUp = document.getElementById("mobileUp");
      const mobilePush = document.getElementById("mobilePush");

      const TRACK = {
        startY: 430,
        finishY: 120,
        lanes: [320, 460, 600],
        leftBound: 240,
        rightBound: 680,
      };

      const characters = [
        {
          key: "perro",
          name: "Perro Centinela",
          description: "Fuerza media, alta resistencia al empuje y olfato que detecta huecos con precisión.",
          stats: { aceleracion: "Media", fuerza: "Alta", equilibrio: "Alto" },
          color: "#fbbf24",
          accent: "#fcd34d",
          type: "dog",
        },
        {
          key: "gato",
          name: "Gata Acróbata",
          description: "Ligera y rápida, se desliza entre rivales pero es más vulnerable a los choques.",
          stats: { aceleracion: "Alta", fuerza: "Media", equilibrio: "Medio" },
          color: "#38bdf8",
          accent: "#60a5fa",
          type: "cat",
        },
        {
          key: "topo",
          name: "Topo Excavador",
          description: "Pesado y estable, avanza a ritmo constante y contraataca con empujes sólidos.",
          stats: { aceleracion: "Baja", fuerza: "Muy alta", equilibrio: "Muy alto" },
          color: "#c084fc",
          accent: "#a855f7",
          type: "mole",
        },
      ];

      const KEY_BINDINGS = {
        up: ["ArrowUp", "w", "W"],
        left: ["ArrowLeft", "a", "A"],
        right: ["ArrowRight", "d", "D"],
        push: [" ", "Space"],
      };

      const keys = new Set();
      const pressed = new Set();

      let player = null;
      let opponents = [];
      let selectedCharacter = null;
      let gameState = "menu";
      let countdown = 3;
      let matchTime = 45;
      let currentLight = "red";
      let lightTimer = 0;
      let lastTime = 0;
      let toastTimer = 0;

      class Runner {
        constructor(options) {
          this.name = options.name;
          this.type = options.type;
          this.color = options.color;
          this.accent = options.accent;
          this.ai = options.ai || false;
          this.lane = options.lane;
          this.baseSpeed = options.baseSpeed;
          this.pushPower = options.pushPower;
          this.balance = options.balance;
          this.reaction = options.reaction || 0.2;
          this.catchChance = options.catchChance || 0.05;
          this.position = 0;
          this.x = TRACK.lanes[this.lane];
          this.y = TRACK.startY;
          this.width = 54;
          this.height = 86;
          this.velocityY = 0;
          this.knockback = 0;
          this.knockTimer = 0;
          this.alive = true;
          this.finished = false;
          this.displayName = options.displayName;
        }

        update(dt) {
          if (!this.alive || this.finished) return;

          if (this.knockTimer > 0) {
            this.knockTimer -= dt;
            this.y += this.knockback * dt;
            if (this.knockTimer <= 0) {
              this.knockback = 0;
            }
          }

          if (this.ai) {
            this.updateAI(dt);
          } else {
            this.updatePlayer(dt);
          }

          this.y += this.velocityY * dt;
          this.y = Math.max(TRACK.finishY, Math.min(TRACK.startY, this.y));

          if (this.y <= TRACK.finishY && !this.finished) {
            this.finished = true;
            this.position = 0;
            if (!this.ai) {
              endRound(true, "¡Ganaste! Alcanzaste la meta antes que todos.");
            }
          }
        }

        updatePlayer(dt) {
          const movingForward = KEY_BINDINGS.up.some((k) => keys.has(k));
          const movingLeft = KEY_BINDINGS.left.some((k) => keys.has(k));
          const movingRight = KEY_BINDINGS.right.some((k) => keys.has(k));

          const acceleration = this.baseSpeed * 1.4;

          if (movingForward) {
            if (currentLight === "red") {
              penalizePlayer("Te moviste en rojo. La muñeca te detectó.");
            } else if (currentLight === "green") {
              this.velocityY = -this.baseSpeed * 1.4;
            }
          } else {
            this.velocityY = 0;
          }

          if (movingLeft) {
            this.x -= 110 * dt;
          }
          if (movingRight) {
            this.x += 110 * dt;
          }

          this.x = Math.max(TRACK.leftBound, Math.min(TRACK.rightBound, this.x));
        }

        updateAI(dt) {
          if (this.knockTimer > 0) {
            this.velocityY = 0;
            return;
          }

          if (currentLight === "green") {
            const target = -this.baseSpeed * (1 + Math.random() * 0.35);
            this.velocityY = lerp(this.velocityY, target, 0.9 * dt);
          } else {
            if (Math.random() < this.catchChance * dt) {
              this.velocityY = -this.baseSpeed * 0.5;
            }
            const stopFactor = this.reaction + Math.random() * 0.3;
            this.velocityY = lerp(this.velocityY, 0, stopFactor);
            if (Math.abs(this.velocityY) > 12) {
              this.alive = false;
              showToast(`${this.displayName} fue eliminado por moverse en rojo.`);
            }
          }
        }

        draw(ctx) {
          if (!this.alive) {
            drawGhost(ctx, this.x, this.y, this.color);
            return;
          }

          const wobble = Math.sin(Date.now() / 200 + this.lane) * 2;
          const bodyTop = this.y - this.height;
          const headRadius = 20;

          ctx.save();
          ctx.translate(this.x, bodyTop + headRadius + wobble);

          // Body
          const gradient = ctx.createLinearGradient(0, -headRadius, 0, this.height);
          gradient.addColorStop(0, shadeColor(this.color, 0.2));
          gradient.addColorStop(1, shadeColor(this.color, -0.2));
          ctx.fillStyle = gradient;
          roundRect(ctx, -22, 0, 44, this.height * 0.65, 16, true, false);

          // Belt
          ctx.fillStyle = this.accent;
          ctx.fillRect(-24, this.height * 0.3, 48, 6);

          // Legs
          ctx.fillStyle = shadeColor(this.color, -0.35);
          ctx.fillRect(-16, this.height * 0.65, 14, this.height * 0.35);
          ctx.fillRect(2, this.height * 0.65, 14, this.height * 0.35);

          // Arms
          ctx.fillStyle = shadeColor(this.color, 0.1);
          ctx.fillRect(-30, this.height * 0.18, 12, this.height * 0.33);
          ctx.fillRect(18, this.height * 0.18, 12, this.height * 0.33);

          // Head
          ctx.beginPath();
          ctx.fillStyle = shadeColor(this.color, 0.15);
          ctx.arc(0, -headRadius, headRadius, 0, Math.PI * 2);
          ctx.fill();

          drawFace(ctx, this.type, this.accent);

          ctx.restore();

          if (this.finished) {
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = "#facc15";
            ctx.font = "700 16px 'Inter'";
            ctx.textAlign = "center";
            ctx.fillText("META", this.x, this.y - this.height - 16);
            ctx.restore();
          }
        }
      }

      function lerp(a, b, t) {
        return a + (b - a) * Math.min(Math.max(t, 0), 1);
      }

      function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function drawFace(ctx, type, accent) {
        ctx.save();
        ctx.translate(0, -18);
        ctx.fillStyle = "#0f172a";
        ctx.beginPath();
        ctx.arc(-6, 0, 3.4, 0, Math.PI * 2);
        ctx.arc(6, 0, 3.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = accent;
        ctx.lineWidth = 2;
        if (type === "dog") {
          ctx.fillStyle = shadeColor(accent, -0.4);
          ctx.beginPath();
          ctx.moveTo(-16, -16);
          ctx.quadraticCurveTo(-4, -28, -2, -10);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(16, -16);
          ctx.quadraticCurveTo(4, -28, 2, -10);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.arc(0, 6, 6, 0, Math.PI);
          ctx.stroke();
        } else if (type === "cat") {
          ctx.fillStyle = accent;
          ctx.beginPath();
          ctx.moveTo(-16, -10);
          ctx.lineTo(-4, -28);
          ctx.lineTo(0, -6);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(16, -10);
          ctx.lineTo(4, -28);
          ctx.lineTo(0, -6);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(-8, 10);
          ctx.quadraticCurveTo(0, 18, 8, 10);
          ctx.stroke();
        } else {
          ctx.fillStyle = shadeColor(accent, -0.3);
          ctx.beginPath();
          ctx.moveTo(-18, -4);
          ctx.lineTo(-6, -18);
          ctx.lineTo(0, -4);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(18, -4);
          ctx.lineTo(6, -18);
          ctx.lineTo(0, -4);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = accent;
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(0, 12, 10, Math.PI, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawGhost(ctx, x, y, color) {
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.ellipse(x, y - 20, 28, 36, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function shadeColor(color, percent) {
        const f = parseInt(color.slice(1), 16);
        const t = percent < 0 ? 0 : 255;
        const p = percent < 0 ? percent * -1 : percent;
        const R = f >> 16;
        const G = (f >> 8) & 0x00ff;
        const B = f & 0x0000ff;
        const newR = Math.round((t - R) * p) + R;
        const newG = Math.round((t - G) * p) + G;
        const newB = Math.round((t - B) * p) + B;
        return `#${(0x1000000 + newR * 0x10000 + newG * 0x100 + newB).toString(16).slice(1)}`;
      }

      function buildMenu() {
        const fragment = document.createDocumentFragment();
        characters.forEach((character) => {
          const item = document.createElement("div");
          item.className = "choice";
          item.innerHTML = `
            <span>${character.name}</span>
            <strong>${character.key.toUpperCase()}</strong>
            <p>${character.description}</p>
            <div style="display:flex;gap:10px;font-size:12px;color:rgba(226,232,240,0.75);flex-wrap:wrap;">
              <span>Velocidad: ${character.stats.aceleracion}</span>
              <span>Fuerza: ${character.stats.fuerza}</span>
              <span>Equilibrio: ${character.stats.equilibrio}</span>
            </div>
          `;
          item.addEventListener("click", () => {
            document.querySelectorAll(".choice").forEach((el) => el.classList.remove("active"));
            item.classList.add("active");
            selectedCharacter = character;
            startBtn.disabled = false;
            updateStatsCard(character);
          });
          fragment.appendChild(item);
        });
        choiceList.appendChild(fragment);
      }

      function updateStatsCard(character) {
        statsCard.innerHTML = `
          <h3>${character.name}</h3>
          <p style="margin:4px 0 12px;color:var(--muted);font-size:13px;">${character.description}</p>
          <ul>
            <li>Aceleración: <strong style="color:${character.accent};">${character.stats.aceleracion}</strong></li>
            <li>Fuerza de empuje: <strong style="color:${character.accent};">${character.stats.fuerza}</strong></li>
            <li>Equilibrio: <strong style="color:${character.accent};">${character.stats.equilibrio}</strong></li>
          </ul>
        `;
      }

      function initGame() {
        if (!selectedCharacter) return;
        menu.classList.add("hidden");
        roundStatus.textContent = "Preparado";
        gameState = "countdown";
        countdown = 3;
        matchTime = 45;
        currentLight = "red";
        lightTimer = 0;
        toastTimer = 0;
        toast.innerHTML = "";

        player = new Runner({
          name: selectedCharacter.name,
          displayName: "Tú",
          type: selectedCharacter.type,
          color: selectedCharacter.color,
          accent: selectedCharacter.accent,
          lane: 1,
          baseSpeed: selectedCharacter.type === "cat" ? 110 : selectedCharacter.type === "dog" ? 95 : 80,
          pushPower: selectedCharacter.type === "topo" ? 180 : selectedCharacter.type === "dog" ? 150 : 130,
          balance: selectedCharacter.type === "cat" ? 0.85 : selectedCharacter.type === "dog" ? 1 : 1.2,
        });

        opponents = [
          new Runner({
            name: "Lince Hacker",
            displayName: "Lince Hacker",
            type: "cat",
            color: "#22d3ee",
            accent: "#38bdf8",
            lane: 0,
            baseSpeed: 105,
            pushPower: 140,
            balance: 0.9,
            ai: true,
            reaction: 0.25,
            catchChance: 0.08,
          }),
          new Runner({
            name: "Bulldog Reactor",
            displayName: "Bulldog Reactor",
            type: "dog",
            color: "#f97316",
            accent: "#fb923c",
            lane: 2,
            baseSpeed: 90,
            pushPower: 170,
            balance: 1.3,
            ai: true,
            reaction: 0.32,
            catchChance: 0.04,
          }),
        ];

        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function loop(timestamp) {
        if (gameState === "menu") return;
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;

        update(dt);
        draw();

        if (gameState !== "menu") {
          requestAnimationFrame(loop);
        }
      }

      function update(dt) {
        if (toastTimer > 0) {
          toastTimer -= dt;
          if (toastTimer <= 0) {
            toast.innerHTML = "";
          }
        }

        if (gameState === "countdown") {
          countdown -= dt;
          if (countdown <= 0) {
            gameState = "playing";
            currentLight = "green";
            lightTimer = randomRange(1.8, 3.4);
            roundStatus.textContent = "¡Corre!";
            showToast("Empieza la carrera. Avanza con cuidado.", 2);
          }
        } else if (gameState === "playing") {
          matchTime -= dt;
          if (matchTime <= 0) {
            endRound(false, "Se acabó el tiempo. No alcanzaste la meta.");
          }

          lightTimer -= dt;
          if (lightTimer <= 0) {
            toggleLight();
          }

          player.update(dt);
          opponents.forEach((opponent) => opponent.update(dt));
          handleCollisions();
          updateRanking();
        }

        updateHud();
      }

      function updateHud() {
        lightStatus.textContent = currentLight === "green" ? "Luz verde" : "Luz roja";
        lightStatus.className = `status-pill ${currentLight}`;

        if (gameState === "countdown") {
          roundStatus.textContent = `Comienza en ${Math.ceil(countdown)}`;
        } else if (gameState === "playing") {
          roundStatus.textContent = "Compitiendo";
        }

        if (gameState === "menu") {
          timeStatus.textContent = "Tiempo —";
        } else {
          timeStatus.textContent = `Tiempo ${Math.max(0, matchTime).toFixed(1)}s`;
        }
      }

      function updateRanking() {
        const racers = [player, ...opponents].filter((r) => r.alive);
        racers.sort((a, b) => a.y - b.y);
        rankingEl.innerHTML = "";
        racers.forEach((racer, index) => {
          const row = document.createElement("span");
          row.innerHTML = `<strong>${index + 1}º</strong> <span>${racer.displayName || racer.name}</span>`;
          rankingEl.appendChild(row);
        });
      }

      function toggleLight() {
        if (currentLight === "green") {
          currentLight = "red";
          lightTimer = randomRange(1.2, 2.6);
          showToast("¡Luz roja! Detente inmediatamente.", 1.6);
        } else {
          currentLight = "green";
          lightTimer = randomRange(1.6, 3.6);
          showToast("Luz verde. Aprovecha para avanzar.", 1.6);
        }
      }

      function endRound(win, message) {
        if (gameState === "finished") return;
        gameState = "finished";
        roundStatus.textContent = win ? "Victoria" : "Derrota";
        showToast(message, 4);
        setTimeout(() => {
          menu.classList.remove("hidden");
          gameState = "menu";
          roundStatus.textContent = "Selecciona un corredor";
          lightStatus.textContent = "—";
          lightStatus.className = "status-pill";
          timeStatus.textContent = "Tiempo —";
          startBtn.disabled = true;
          selectedCharacter = null;
          document.querySelectorAll(".choice").forEach((el) => el.classList.remove("active"));
          statsCard.innerHTML = "";
        }, 4200);
      }

      function penalizePlayer(message) {
        if (gameState !== "playing") return;
        player.alive = false;
        endRound(false, message);
      }

      function attemptPush() {
        if (gameState !== "playing") return;
        const nearest = opponents
          .filter((opponent) => opponent.alive && !opponent.finished)
          .map((opponent) => ({
            opponent,
            distance: Math.hypot(opponent.x - player.x, opponent.y - player.y),
          }))
          .sort((a, b) => a.distance - b.distance)[0];

        if (!nearest || nearest.distance > 90) {
          showToast("No hay rivales al alcance para empujar.", 1.2);
          return;
        }

        const target = nearest.opponent;
        target.knockback = 220;
        target.knockTimer = 0.4;
        target.velocityY = 0;
        showToast(`Empujaste a ${target.displayName}.`, 1.2);
        if (Math.random() > target.balance) {
          target.alive = false;
          showToast(`${target.displayName} rodó fuera de la pista.`, 1.6);
        }
      }

      function shiftLane(direction) {
        if (!player || gameState !== "playing") return;
        player.x += direction * 80;
        player.x = Math.max(TRACK.leftBound, Math.min(TRACK.rightBound, player.x));
      }

      function handleCollisions() {
        const racers = [player, ...opponents].filter((r) => r.alive);
        for (let i = 0; i < racers.length; i++) {
          for (let j = i + 1; j < racers.length; j++) {
            const a = racers[i];
            const b = racers[j];
            if (Math.abs(a.x - b.x) < 38 && Math.abs(a.y - b.y) < 68) {
              const push = (a.y < b.y ? -1 : 1) * 40;
              a.y += push * 0.05;
              b.y -= push * 0.05;
            }
          }
        }
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawTrack();
        drawDoll();
        drawPlayers();
        drawCountdown();
      }

      function drawBackground() {
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#020617");
        grd.addColorStop(0.55, "#030713");
        grd.addColorStop(1, "#040712");
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.globalAlpha = 0.35;
        for (let i = 0; i < 80; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * 140;
          const size = Math.random() * 2;
          ctx.fillStyle = i % 2 ? "rgba(96,165,250,0.35)" : "rgba(16,185,129,0.3)";
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawTrack() {
        ctx.fillStyle = varColor("--track");
        ctx.fillRect(200, 100, 560, 360);

        ctx.save();
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = "rgba(148, 163, 184, 0.08)";
          ctx.fillRect(200, 100 + i * 120, 560, 120);
        }
        ctx.restore();

        ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
        ctx.fillRect(200, TRACK.startY + 20, 560, 12);

        ctx.fillStyle = "rgba(248, 113, 113, 0.45)";
        ctx.fillRect(200, TRACK.finishY - 12, 560, 12);

        ctx.setLineDash([16, 12]);
        ctx.strokeStyle = "rgba(148, 163, 184, 0.35)";
        ctx.lineWidth = 2;
        for (let i = 0; i < 3; i++) {
          const x = TRACK.lanes[i];
          ctx.beginPath();
          ctx.moveTo(x - 40, 120);
          ctx.lineTo(x - 40, 460);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 40, 120);
          ctx.lineTo(x + 40, 460);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      function drawDoll() {
        const x = 120;
        const y = 170;
        ctx.save();
        ctx.translate(x, y);

        ctx.fillStyle = currentLight === "green" ? "#34d399" : "#f87171";
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(0, 0, 32, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = "#fcd34d";
        roundRect(ctx, -24, 28, 48, 90, 18, true, false);
        ctx.fillStyle = "#f97316";
        ctx.fillRect(-24, 68, 48, 8);
        ctx.fillStyle = "#fcd34d";
        ctx.fillRect(-18, 118, 16, 46);
        ctx.fillRect(2, 118, 16, 46);

        ctx.fillStyle = "#fbbf24";
        ctx.beginPath();
        ctx.arc(-14, -6, 6, 0, Math.PI * 2);
        ctx.arc(14, -6, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#1f2937";
        ctx.beginPath();
        ctx.arc(-10, -8, 3.5, 0, Math.PI * 2);
        ctx.arc(10, -8, 3.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#1f2937";
        ctx.fillRect(-16, 10, 32, 4);

        ctx.restore();
      }

      function drawPlayers() {
        [...opponents, player].filter(Boolean).forEach((runner) => runner.draw(ctx));
      }

      function drawCountdown() {
        if (gameState === "countdown") {
          ctx.save();
          ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#e2e8f0";
          ctx.font = "700 96px 'Inter'";
          ctx.textAlign = "center";
          ctx.fillText(Math.ceil(countdown), canvas.width / 2, canvas.height / 2 + 30);
          ctx.restore();
        }
      }

      function showToast(message, duration = 1.4) {
        toast.innerHTML = `<div class="toast-message">${message}</div>`;
        toastTimer = duration;
      }

      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function varColor(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name);
      }

      window.addEventListener("keydown", (event) => {
        if (KEY_BINDINGS.up.concat(KEY_BINDINGS.left, KEY_BINDINGS.right, KEY_BINDINGS.push).includes(event.key)) {
          event.preventDefault();
        }
        keys.add(event.key);
        pressed.add(event.key);
        if (KEY_BINDINGS.push.includes(event.key)) {
          attemptPush();
        }
        if (event.key === "Escape" && gameState !== "menu") {
          endRound(false, "Abandonaste la partida actual.");
        }
      });

      window.addEventListener("keyup", (event) => {
        keys.delete(event.key);
      });

      mobileUp.addEventListener("pointerdown", () => {
        keys.add("ArrowUp");
      });
      mobileUp.addEventListener("pointerup", () => {
        keys.delete("ArrowUp");
      });
      mobileUp.addEventListener("pointerout", () => keys.delete("ArrowUp"));

      mobilePush.addEventListener("click", () => {
        attemptPush();
      });

      canvas.addEventListener("pointerdown", (event) => {
        if (gameState !== "playing") return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        if (x < canvas.width / 2) {
          shiftLane(-1);
        } else {
          shiftLane(1);
        }
      });

      startBtn.addEventListener("click", initGame);
      viewKeys.addEventListener("click", () => {
        showToast("Mover: flechas/WASD · Empujar: barra espaciadora", 2.4);
      });

      buildMenu();
    </script>
  </body>
</html>
